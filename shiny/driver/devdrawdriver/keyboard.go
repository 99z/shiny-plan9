// Copyright 2016-2016 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package devdrawdriver

import (
	"bufio"
	"fmt"
	"golang.org/x/mobile/event/key"
	"os"
)

var currentModifiers key.Modifiers

// keyboardEventHandler writes rawon to /dev/consctl, and then continuously
// reads runes from /dev/cons and converts them to key.Event messages, which
// it passes along the notifier channel.
func keyboardEventHandler(notifier chan *key.Event) {
	ctl, err := os.OpenFile("/dev/consctl", os.O_WRONLY, 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error converting keyboard input to raw mode. Could not open /dev/consctl.\n")
		return
	}
	// Closing /dev/consctl will cause the keyboard to stop being in raw mode. So defer the close instead of
	// closing it right away.
	defer ctl.Close()
	rawon := []byte("rawon")
	n, err := ctl.Write(rawon)
	if err != nil || n != 5 {
		fmt.Fprintf(os.Stderr, "Error converting keyboard into raw mode. Could not write rawon..\n")
		return
	}

	cons, err := os.Open("/dev/cons")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Could not open keyboard driver.\n")
		return

	}
	// *os.File doesn't implement ReadRune, and /dev/cons will return one rune at
	// a time in raw mode, so convert the file Reader to a bufio.Reader so that
	// it implements the ReadRune() interface.
	keyReader := bufio.NewReader(cons)
	for {
		r, _, err := keyReader.ReadRune()
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error reading key from console.\n")
			continue
		}
		var code key.Code
		code, currentModifiers = RuneToCode(r)
		notifier <- &key.Event{
			Rune:      r,
			Code:      code,
			Modifiers: currentModifiers,
			Direction: key.DirPress,
		}

	}
}

// RuneToCode takes a unicode rune that came off of /dev/cons, and guesses
// keycode generated that rune. Since Plan 9 doesn't directly tell us what
// key resulted in the key press, we have to take a guess. This assumed a
// standard US keyboard layout where runes are generated in the obvious way.
//
// 9front has /dev/kbd which tells more information about the keypresses instead
// of the runes generated by the key press, but /dev/cons is the only thing
// that can be assumed to be present on every Plan 9 instance, so even if
// support is implemented for /dev/kbd this needs to remain here as a fallback.
//
// This only supports the shift and control modifiers, because alt is used
// as the compose key at a lower level of the OS before passing the rune along
// /dev/cons
func RuneToCode(r rune) (key.Code, key.Modifiers) {
	// TODO: Look into using /dev/kbd on 9front when available.

	// first handle ones that can easily be calculated from the
	// ASCII ordering.
	if r >= 'a' && r <= 'z' {
		alphabetIndex := key.Code(r - 'a')
		return key.Code(alphabetIndex + key.CodeA), 0
	}
	if r >= 'A' && r <= 'Z' {
		alphabetIndex := key.Code(r - 'A')
		return key.Code(alphabetIndex + key.CodeA), key.ModShift
	}
	if r >= 1 && r <= 26 && r != '\n' && r != '\t' && r != '\b' {
		// control ASCII codes are 1-26, but make them 0 indexed to
		// add to 'A' key.
		// \n and \t are more commonly generated by the enter and tab
		// keys than ctrl-M or ctrl-J, so exclude them.
		alphabetIndex := key.Code(r - 1)
		return key.Code(alphabetIndex + key.CodeA), key.ModControl
	}

	// then handle the rest
	switch r {
	// Number row. Assume they came from the numbers and not the numpad, because for
	// all we know the keyboard being used doesn't even have a numpad
	case '`':
		return key.CodeGraveAccent, 0
	case '~':
		return key.CodeGraveAccent, key.ModShift
	// Control '~' doesn't generate anything on /dev/cons
	case '0':
		return key.Code0, 0
	case ')':
		return key.Code0, key.ModShift
	case '\x10':
		return key.Code0, key.ModControl
	case '1':
		return key.Code1, 0
	case '!':
		return key.Code1, key.ModShift
	case '\x11':
		return key.Code0, key.ModControl
	case '2':
		return key.Code2, 0
	case '@':
		return key.Code2, key.ModShift
	case '\x12':
		return key.Code0, key.ModControl
	case '3':
		return key.Code3, 0
	case '#':
		return key.Code3, key.ModShift
	case '\x13':
		return key.Code0, key.ModControl
	case '4':
		return key.Code4, 0
	case '$':
		return key.Code4, key.ModShift
	case '\x14':
		return key.Code0, key.ModControl
	case '5':
		return key.Code5, 0
	case '%':
		return key.Code5, key.ModShift
	case '\x15':
		return key.Code0, key.ModControl
	case '6':
		return key.Code6, 0
	case '^':
		return key.Code6, key.ModShift
	case '\x16':
		return key.Code0, key.ModControl
	case '7':
		return key.Code7, 0
	case '&':
		return key.Code7, key.ModShift
	case '\x17':
		return key.Code0, key.ModControl
	case '8':
		return key.Code8, 0
	case '*':
		return key.Code8, key.ModShift
	case '\x18':
		return key.Code0, key.ModControl
	case '9':
		return key.Code9, 0
	case '(':
		return key.Code9, key.ModShift
	case '\x19':
		return key.Code0, key.ModControl
	case '-':
		return key.CodeHyphenMinus, 0
	case '_':
		return key.CodeHyphenMinus, key.ModShift
	case '\r':
		return key.CodeHyphenMinus, key.ModControl
	case '=':
		return key.CodeEqualSign, 0
	case '+':
		return key.CodeEqualSign, key.ModShift
	case '\x1d':
		return key.CodeHyphenMinus, key.ModControl
	// other special characters
	case 27:
		return key.CodeEscape, 0
	case '\n':
		return key.CodeReturnEnter, 0
	case '\b':
		return key.CodeDeleteBackspace, 0
	case '\t':
		return key.CodeTab, 0
	case ' ':
		return key.CodeSpacebar, 0
	case '[':
		return key.CodeLeftSquareBracket, 0
	// Ctrl-[ is the same as esc, which is treated as the Esc key.
	case ']':
		return key.CodeRightSquareBracket, 0
	// Ctrl-] is the same as ctrl-minus
	case '{':
		return key.CodeLeftSquareBracket, key.ModShift
	case '}':
		return key.CodeRightSquareBracket, key.ModShift
	case '\\':
		return key.CodeBackslash, 0
	case '|':
		return key.CodeBackslash, key.ModShift
	case '\x1c':
		return key.CodeBackslash, key.ModControl
	case ';':
		return key.CodeSemicolon, 0
	case ':':
		return key.CodeSemicolon, key.ModShift
	case '\'':
		return key.CodeApostrophe, 0
	case '"':
		return key.CodeApostrophe, key.ModShift
	case ',':
		return key.CodeComma, 0
	case '<':
		return key.CodeComma, key.ModShift
	case '.':
		return key.CodeFullStop, 0
	case '>':
		return key.CodeFullStop, key.ModShift
	case '/':
		return key.CodeSlash, 0
	case '?':
		return key.CodeSlash, key.ModShift
	// Aptly named unicode codepoints.
	case '\uf001':
		return key.CodeF1, 0
	case '\uf002':
		return key.CodeF2, 0
	case '\uf003':
		return key.CodeF3, 0
	case '\uf004':
		return key.CodeF4, 0
	case '\uf005':
		return key.CodeF5, 0
	case '\uf006':
		return key.CodeF6, 0
	case '\uf007':
		return key.CodeF7, 0
	case '\uf008':
		return key.CodeF8, 0
	case '\uf009':
		return key.CodeF9, 0
	case '\uf00a':
		return key.CodeF10, 0
	case '\uf00b':
		return key.CodeF11, 0
	case '\uf00c':
		return key.CodeF12, 0

	// Magic unicode characters that came from
	// pushing keys on my keyboard and seeing what
	// came out.
	case '\uf012':
		return key.CodeRightArrow, 0
	case '\uf011':
		return key.CodeLeftArrow, 0
	case '\uf00e':
		return key.CodeUpArrow, 0
	case '\uf800':
		return key.CodeDownArrow, 0

	case '\uf014':
		return key.CodeInsert, 0
	case '\u007f':
		return key.CodeDeleteForward, 0
	case '\uf00f':
		return key.CodePageUp, 0
	case '\uf013':
		return key.CodePageDown, 0
	case '\uf00d':
		return key.CodeHome, 0
	case '\uf018':
		return key.CodeEnd, 0
	default:
		fmt.Fprintf(os.Stderr, "Unknown unicode character %d %c %s, %u unsupported by /dev/draw driver.\n", r, r, r, r)
		return key.CodeUnknown, 0
	}
}
